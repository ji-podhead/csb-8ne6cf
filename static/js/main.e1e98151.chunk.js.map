{"version":3,"sources":["index.js"],"names":["arraybuffer","Uint32Array","iIB","THREE","attr1","attr2","geometry","copy","vertexBuffer","Float32Array","positions","setAttribute","uvs","indices","Uint16Array","setIndex","instanceCount","material","color","onBeforeCompile","shader","vertexShader","replace","left","mesh","InstancedMesh","useThree","scene","camera","gl","useEffect","add","directional","position","set","console","log","gridHelper","useFrame","needsUpdate","MainFunction","style","width","height","ReactDOM","render","document","getElementById"],"mappings":"iOAAA,0EAOMA,EAAc,IAAIC,YADZ,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,IAEpDC,EAAM,IAAIC,6BAAiCH,EAAa,EAAG,GAC3DI,EAAQ,IAAID,6BAAiCD,EAAK,EAAG,GACrDG,EAAQ,IAAIF,6BAAiCD,EAAK,EAAG,GACrDI,GAAW,IAAIH,2BAAgCI,KAAK,IAAIJ,cAAkB,EAAG,EAAG,IAIhFK,EAAe,IAAIL,oBACvB,IAAIM,aAAa,EAEd,EACD,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GACC,GACA,EACD,EACA,EACA,EACA,EACA,EACA,EACA,GACC,EACD,EACA,EACA,EACA,EACA,EACA,EAEA,EACA,GACC,EACD,EACA,EACA,EACA,EACA,GACC,EACD,GACC,EACD,EACA,EACA,EACA,EACA,EACA,GACC,GACA,EACD,EACA,EACA,EACA,EACA,GACC,GACA,GACA,EACD,EACA,EACA,EACA,EACA,GAEC,EACD,GACC,EACD,EACA,EACA,EACA,EACA,GACC,EACD,EACA,EACA,EACA,EACA,EACA,EACA,GACC,GACA,GACA,EACD,EACA,EACA,EACA,EACA,GACC,GACA,EACD,EACA,EACA,EACA,EACA,EACA,EAEA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GACC,EACD,EACA,EACA,EACA,EACA,EACA,GACC,EACD,EACA,EACA,EACA,EACA,EACA,EACA,GACC,GACA,EACD,EACA,EACA,EACA,EACA,GAEC,EACD,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GACC,EACD,GACC,EACD,EACA,EACA,EACA,EACA,EACA,EACA,GACC,EACD,EACA,EACA,EACA,EACA,EAEA,GACC,EACD,EACA,EACA,EACA,EACA,EACA,GACC,GACA,EACD,EACA,EACA,EACA,EACA,EACA,EACA,GACC,GACA,EACD,EACA,EACA,EACA,EACA,GACC,GACA,GACA,EACD,EACA,EACA,EACA,EACA,IAEF,GAGIC,EAAY,IAAIP,6BAAiCK,EAAc,EAAG,GACxEF,EAASK,aAAa,WAAYD,GAElC,IAAME,EAAM,IAAIT,6BAAiCK,EAAc,EAAG,GAClEF,EAASK,aAAa,KAAMC,GAC5B,IAAMC,EAAU,IAAIC,YAAY,CAC9B,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GACA,EACA,GACA,GACA,EACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,KAEFR,EAASS,SAAS,IAAIZ,kBAAsBU,EAAS,IACrDP,EAASU,cAAgB,GACzBV,EAASK,aAAa,QAASP,GAC/BE,EAASK,aAAa,QAASN,GAC/BL,EAAY,GAAK,EACjB,IAAIiB,EAAW,IAAId,sBAA0B,CAC3Ce,MAAO,SAEPC,gBAAiB,SAACC,GAChBA,EAAOC,aAAe,4EAGlBD,EAAOC,aAAY,UACrBC,QAAQ,0BAAD,iHAQTC,GAAO,EACPC,EAAO,IAAIrB,OAAWG,EAAUW,GACpC,SAASQ,IACP,MAA8BC,cAAtBC,EAAK,EAALA,MAAWC,GAAF,EAAFC,GAAU,EAAND,QA4BnB,OA3BAE,qBAAU,WACRH,EAAMI,IAAI,IAAI5B,eAAmB,UACjC,IAAI6B,EAAc,IAAI7B,mBAAuB,SAC7C6B,EAAYC,SAASC,IAAI,IAAK,IAAO,KACrCC,QAAQC,IAAIR,GACZA,EAAOK,SAASC,IAAI,EAAG,EAAG,IAC1BP,EAAMI,IAAIC,GACV,IAAMK,EAAa,IAAIlC,aAAiB,IAAK,KAC7CwB,EAAMI,IAAIM,GACVV,EAAMI,IAAIP,KACT,IACHc,aAAS,YACM,IAATf,EACEvB,EAAY,GAAK,GACnBA,EAAY,IAAM,EAElBuB,GAAO,EAGLvB,EAAY,GAAK,EACnBA,EAAY,IAAM,EAElBuB,GAAO,EAGXnB,EAAMmC,aAAc,KAEf,gCAET,SAASC,IACP,OACE,yBAAKC,MAAO,CAAEC,MAAO,OAAQC,OAAQ,SACnC,kBAAC,IAAM,KACL,kBAAClB,EAAa,QAKtBmB,IAASC,OAEP,kBAACL,EAAY,MACbM,SAASC,eAAe,U","file":"static/js/main.e1e98151.chunk.js","sourcesContent":["import React, { useRef, useMemo, useState, useEffect } from 'react'\nimport ReactDOM from 'react-dom'\n\nimport { Canvas, useFrame, useThree } from '@react-three/fiber'\nimport './styles.css'\nimport * as THREE from 'three'\nconst arr = [0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7]\nconst arraybuffer = new Uint32Array(arr)\nconst iIB = new THREE.InstancedInterleavedBuffer(arraybuffer, 2, 1) // this part is important\nconst attr1 = new THREE.InterleavedBufferAttribute(iIB, 1, 0)\nconst attr2 = new THREE.InterleavedBufferAttribute(iIB, 1, 1)\nconst geometry = new THREE.InstancedBufferGeometry().copy(new THREE.BoxGeometry(1, 1, 1))\n//\t\tconst geometry = new THREE.InstancedBufferGeometry();\n// per mesh data x,y,z,w,u,v,s,t for 4-element alignment\n// only use x,y,z and u,v; but x, y, z, nx, ny, nz, u, v would be a good layout\nconst vertexBuffer = new THREE.InterleavedBuffer(\n  new Float32Array([\n    // Front\n    -1,\n    1,\n    1,\n    0,\n    0,\n    0,\n    0,\n    0,\n    1,\n    1,\n    1,\n    0,\n    1,\n    0,\n    0,\n    0,\n    -1,\n    -1,\n    1,\n    0,\n    0,\n    1,\n    0,\n    0,\n    1,\n    -1,\n    1,\n    0,\n    1,\n    1,\n    0,\n    0,\n    // Back\n    1,\n    1,\n    -1,\n    0,\n    1,\n    0,\n    0,\n    0,\n    -1,\n    1,\n    -1,\n    0,\n    0,\n    0,\n    0,\n    0,\n    1,\n    -1,\n    -1,\n    0,\n    1,\n    1,\n    0,\n    0,\n    -1,\n    -1,\n    -1,\n    0,\n    0,\n    1,\n    0,\n    0,\n    // Left\n    -1,\n    1,\n    -1,\n    0,\n    1,\n    1,\n    0,\n    0,\n    -1,\n    1,\n    1,\n    0,\n    1,\n    0,\n    0,\n    0,\n    -1,\n    -1,\n    -1,\n    0,\n    0,\n    1,\n    0,\n    0,\n    -1,\n    -1,\n    1,\n    0,\n    0,\n    0,\n    0,\n    0,\n    // Right\n    1,\n    1,\n    1,\n    0,\n    1,\n    0,\n    0,\n    0,\n    1,\n    1,\n    -1,\n    0,\n    1,\n    1,\n    0,\n    0,\n    1,\n    -1,\n    1,\n    0,\n    0,\n    0,\n    0,\n    0,\n    1,\n    -1,\n    -1,\n    0,\n    0,\n    1,\n    0,\n    0,\n    // Top\n    -1,\n    1,\n    1,\n    0,\n    0,\n    0,\n    0,\n    0,\n    1,\n    1,\n    1,\n    0,\n    1,\n    0,\n    0,\n    0,\n    -1,\n    1,\n    -1,\n    0,\n    0,\n    1,\n    0,\n    0,\n    1,\n    1,\n    -1,\n    0,\n    1,\n    1,\n    0,\n    0,\n    // Bottom\n    1,\n    -1,\n    1,\n    0,\n    1,\n    0,\n    0,\n    0,\n    -1,\n    -1,\n    1,\n    0,\n    0,\n    0,\n    0,\n    0,\n    1,\n    -1,\n    -1,\n    0,\n    1,\n    1,\n    0,\n    0,\n    -1,\n    -1,\n    -1,\n    0,\n    0,\n    1,\n    0,\n    0\n  ]),\n  8\n)\n// Use vertexBuffer, starting at offset 0, 3 items in position attribute\nconst positions = new THREE.InterleavedBufferAttribute(vertexBuffer, 3, 0)\ngeometry.setAttribute('position', positions)\n// Use vertexBuffer, starting at offset 4, 2 items in uv attribute\nconst uvs = new THREE.InterleavedBufferAttribute(vertexBuffer, 2, 4)\ngeometry.setAttribute('uv', uvs)\nconst indices = new Uint16Array([\n  0,\n  2,\n  1,\n  2,\n  3,\n  1,\n  4,\n  6,\n  5,\n  6,\n  7,\n  5,\n  8,\n  10,\n  9,\n  10,\n  11,\n  9,\n  12,\n  14,\n  13,\n  14,\n  15,\n  13,\n  16,\n  17,\n  18,\n  18,\n  17,\n  19,\n  20,\n  21,\n  22,\n  22,\n  21,\n  23\n])\ngeometry.setIndex(new THREE.BufferAttribute(indices, 1))\ngeometry.instanceCount = 10\ngeometry.setAttribute('attr1', attr1)\ngeometry.setAttribute('attr2', attr2)\narraybuffer[0] = 0\nlet material = new THREE.MeshLambertMaterial({\n  color: 0xff0000,\n  //wireframe: true,\n  onBeforeCompile: (shader) => {\n    shader.vertexShader = `\n      attribute uint attr1;\n      attribute uint attr2;\n      ${shader.vertexShader}\n    `.replace(\n      `#include <begin_vertex>`,\n      `#include <begin_vertex>\n        transformed.xy += vec2(attr1, attr2); // check, that it's working\n      `\n    )\n  }\n})\nlet left = true\nlet mesh = new THREE.Mesh(geometry, material)\nfunction InstancedMesh() {\n  const { scene, gl, camera } = useThree()\n  useEffect(() => {\n    scene.add(new THREE.AmbientLight(0x777777))\n    let directional = new THREE.DirectionalLight(0x888888)\n    directional.position.set(100, 10000, 700)\n    console.log(camera)\n    camera.position.set(0, 0, 20)\n    scene.add(directional)\n    const gridHelper = new THREE.GridHelper(100, 100)\n    scene.add(gridHelper)\n    scene.add(mesh)\n  }, [])\n  useFrame(() => {\n    if (left === true) {\n      if (arraybuffer[0] < 10) {\n        arraybuffer[0] += 1\n      } else {\n        left = false\n      }\n    } else {\n      if (arraybuffer[0] > 0) {\n        arraybuffer[0] -= 1\n      } else {\n        left = true\n      }\n    }\n    attr1.needsUpdate = true\n  })\n  return <scene />\n}\nfunction MainFunction() {\n  return (\n    <div style={{ width: '100%', height: '100%' }}>\n      <Canvas>\n        <InstancedMesh />\n      </Canvas>\n    </div>\n  )\n}\nReactDOM.render(\n  //Main function because of useState\n  <MainFunction />,\n  document.getElementById('root')\n)\n"],"sourceRoot":""}